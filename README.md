# A Simple n-Body Simulator using Real World Data
### Table of Contents
1. [Program Motivation](#Program-Motivation)
2. [The System Structure](#The-System-Structure)
    - [The Base Body](#The-Basic-Body)
    - [Real World Data](#Real-World-Data)
    - [Gravitation Calculations](#Gravitation-Calculations)
4. [Visualizing the System](#Visualizing-the-System)
    - [Kiss3d Engine](#Kiss3d-Engine)
    - [Orbital Trails](#Orbital-Trails)
5. [Simulation Testing](#Simulation-Testing)
6. [Future Plans](#Future-Plans)
## Programing Motivation
I admit that n-body simulators are a dime-a-dozen these days but a lot of them just seem to take some randomly generated point-masses and watch them spin in globular clusters. Where are the lagrange points, orbital resonance, or temporarily captured asteroids? There are many kinds of simulators and they all have their own specialties from simple python scripts to academic simulations of galactic collisions but I have yet to find a three dimensional simulation of our whole solar system using real world data. What I want is to see something real and believable, something that allows me to see what my eyes cannot perceive: the great distance between the tiny actors that dance around a swirling ball of chaos and the vast black background of emptiness behind them.
## The System Structure
My solution to the n-body simulation is nothing fancy. The program is basically a vector of bodies that exert gravitational forces on each other using the synchronized Leapfrog integration method in the form of 'kick-drift-kick'. I decided to store bodies' mass as the standard gravitational parameter, simply the gravitational constant multiplied by it's mass.
### The Basic Body
There are four piece of information each body needs to keep track of: position, velocity, standard gravitational parameter, and radius. Only the former two are required for the successful construction of a body and placement into a system but without the standard gravitational parameter, the body will not apply any gravitational forces to other bodies. Lastly, there is the completely optional radius, which can hold a value for attempting to draw a scale model but otherwise unused by the simulation itself.
### Real World Data
The real beauty of the program is the ability to use real world data taken from [NASA's JPL HORIZONS](https://ssd.jpl.nasa.gov/horizons.cgi) system. With a relatively simple regex parsing of data returned from a simple get request, the program is able to grab accurate information of known bodies in our solar system at any date desired. This allows one to construct systems including all objects or can just look as localized planet-moon systems. While the code does not currently support changing the coordinate origin, implementing such is just a matter of adding another argument to a function call and formatting the get request appropriately. More information on using HORIZONS can be found at https://ssd.jpl.nasa.gov/?horizons#email.
### Gravitation Calculations
Being only a simple simulation, the code only really does one function that exchanges gravitational forces between all objects in the system. It was originally written as a simple iterator that was then parallelized after adding smart pointers and locks. This is executed as a second derivative integration using the leapfrog kick-step-kick method that apply half the acceleration to each body, moves each object  by one time step and then applies another half time step of acceleration.
##  Visualizing the System
An n body simulator is rather lack luster on its own, so some visuals were added to allow anyone to see what was going on. This was more of an afterthought once I had got the program *supposedly* running properly. I say this because when you just see a lot of floating point numbers vomited out by console faster than you can read them, you don't have any real confidence in the system implemented. So to make sure things were actually orbiting each other, I added some simple graphics to quickly diagnose what was going.
### Kiss3d Engine
I have to give a shout out to [Keep It Simple, Stupid 3d graphics engine](#https://github.com/sebcrozet/kiss3d). I have written a few graphics pipelines in the pass, first using OpenGL 1.2 (when you only had triangles) when I was in my tweens and more recently in Rust ([seen here](#https://github.com/caemanswartz/Rust-OpenGL-Pipeline)). As you can see from my own code, it is just as Kiss3d's README says, "The frustration that todayâ€™s 3D graphics library are...\[t\]oo low level: you have to write your own shaders and opening a window takes 8 hours, 300 lines of code and 10L of coffee." Having no interest in writing all of what I wanted to do, or desire to use anything fancy, I tried out this simple crate and have loved almost every minute of using it. Since all I really wanted was to draw some spheres on a screen that moved around. Eventually, I realized that just having tiny scale dots wasn't really enough and had to draw some lines as movement trails and texts to differentiate individual bodies but most of these feature were already in the engine and easy to adapt to my needs, the only tweak needed was to approximate the 2d window coordinates for a 3d point since the text drawing is flat.
### Orbital Trails
The only other data structure from the system in the code is some simple 'orbital trails'. at least thats what they were when it was just the Sun and Planets. Really, it is a tracking of the objects position in space, which looks nice until you start adding moons that spin around and then it starts to look rather messy, except in the case of Uranus, since the moons orbit don't orbit on it orbital plane like most other planets. Even with this hackish approach, it helps to visualize the motion and see the location of bodies at great distances.
## Simulation Testing
I wasn't satisfied with just having some masses spinning around each other seemingly randomly so I devised some tests against the HORIZONS data. These simulation tests are simply downloading at a specific time, running the simulation and comparing them to what HORIZONS has at the ending date. The most difficult part of this was coming up with what to test. After trying several different approaches I settled on just checking that my simulation bodyss distances to the Sun are within one percent of the value given by HORIZONS. While it works well for the inner planets, it becomes less effective as you go further away from the Sun. Keep in mind that these tests always pass. They are not a unit or integration tests, they look at accuracy of the ending position in the simulation and output this to console to help understand how accurate or not the simulation is.
## Future Plans
There are quite a few things that need to be fixed up. First, the regex parsing of names needs a little work; specifically some moons names come out wrong but all necessary information is processed properly. This is trivial pattern matching that just needs some analysis of what the actual output looks like (I wrote the regex from the output for the Sun(10), Mercury (199), Earth (399), Ceres (AA801 AA), and Jupiter (599) alone). The second would be replacing the floats with Rationals since the simulation is not at very accurate once you get to Pluto. Watching Pluto closely for just a few minutes shows everything but Charon being thrown out of orbit eventually. While rational may solve this issue, it could also be the lack of gravitational mass parameters for anything but the two main bodies in a system that is build around near perfect resonances (as it is theorized 3 of Pluto's 5 moons are condensed gasses that collected in these locations) but HORIZONS does not have this data and it would have to be found elsewhere and added in manually. The last piece that would be useful would be having each body keep track of whose sphere of influence they are under. Mainly, this would allow the orbital paths to be drawn relative to the main body and not just globally. While Uranus would lose its unique spiralling pattern, it would allow one to see the actual orbits of moons around planets instead of their path through an 'arbitrarily' defined space and I say arbitrary because the Sun doesn't orbit around its Barycenter perfectly since not all of the solar system's mass is accounted for. If implemented correctly it could also be used to create a simple AI that tries to navigate this space using only 2-body mechanics, as most orbital maneuvers are planned.